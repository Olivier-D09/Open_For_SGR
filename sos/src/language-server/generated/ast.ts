/******************************************************************************
 * This file was generated by langium-cli 1.0.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable */
import { AstNode, AbstractAstReflection, Reference, ReferenceInfo, TypeMetaData } from 'langium';

export type AbstractRule = ParserRule | TerminalRule;

export const AbstractRule = 'AbstractRule';

export function isAbstractRule(item: unknown): item is AbstractRule {
    return reflection.isInstance(item, AbstractRule);
}

export type AbstractType = Action | Interface | ParserRule | Type;

export const AbstractType = 'AbstractType';

export function isAbstractType(item: unknown): item is AbstractType {
    return reflection.isInstance(item, AbstractType);
}

export type Condition = Conjunction | Disjunction | LiteralCondition | Negation | ParameterReference;

export const Condition = 'Condition';

export function isCondition(item: unknown): item is Condition {
    return reflection.isInstance(item, Condition);
}

export type Expression = BinaryExpression | BooleanExpression | MemberCall | NilExpression | NumberExpression | StringExpression | UnaryExpression;

export const Expression = 'Expression';

export function isExpression(item: unknown): item is Expression {
    return reflection.isInstance(item, Expression);
}

export type FeatureName = string;

export type NamedElement = FieldMember | MethodMember | RWRule | RuleOpening | SoSPrimitiveType | Struct | TemporaryVariable | VariableDeclaration;

export const NamedElement = 'NamedElement';

export function isNamedElement(item: unknown): item is NamedElement {
    return reflection.isInstance(item, NamedElement);
}

export type PrimitiveType = 'Date' | 'bigint' | 'boolean' | 'number' | 'string';

export type QualifiedName = string;

export interface AbstractElement extends AstNode {
    readonly $container: Alternatives | Assignment | AtomType | CharacterRange | CrossReference | Grammar | Group | NegatedToken | ParserRule | TerminalAlternatives | TerminalGroup | TerminalRule | UnorderedGroup | UntilToken;
    readonly $type: 'AbstractElement' | 'Action' | 'Alternatives' | 'Assignment' | 'CharacterRange' | 'CrossReference' | 'Group' | 'Keyword' | 'NegatedToken' | 'RegexToken' | 'RuleCall' | 'TerminalAlternatives' | 'TerminalGroup' | 'TerminalRuleCall' | 'UnorderedGroup' | 'UntilToken' | 'Wildcard';
    cardinality?: '*' | '+' | '?'
}

export const AbstractElement = 'AbstractElement';

export function isAbstractElement(item: unknown): item is AbstractElement {
    return reflection.isInstance(item, AbstractElement);
}

export interface AtomType extends AstNode {
    readonly $container: Type | TypeAttribute;
    readonly $type: 'AtomType';
    isArray: boolean
    isRef: boolean
    keywordType?: Keyword
    primitiveType?: PrimitiveType
    refType?: Reference<AbstractType>
}

export const AtomType = 'AtomType';

export function isAtomType(item: unknown): item is AtomType {
    return reflection.isInstance(item, AtomType);
}

export interface BinaryExpression extends AstNode {
    readonly $container: BinaryExpression | Conclusion | MemberCall | SchedulingConstraint | SchedulingRule | SemanticEquivalence | SequenceLoop | UnaryExpression | VariableDeclaration;
    readonly $type: 'BinaryExpression';
    left: Expression
    operator: '!=' | '*' | '+' | '-' | '/' | '<' | '<=' | '=' | '==' | '>' | '>=' | 'and' | 'or' | 'xor'
    right: Expression
}

export const BinaryExpression = 'BinaryExpression';

export function isBinaryExpression(item: unknown): item is BinaryExpression {
    return reflection.isInstance(item, BinaryExpression);
}

export interface BooleanExpression extends AstNode {
    readonly $container: BinaryExpression | Conclusion | MemberCall | SchedulingConstraint | SchedulingRule | SemanticEquivalence | SequenceLoop | UnaryExpression | VariableDeclaration;
    readonly $type: 'BooleanExpression';
    value: boolean
}

export const BooleanExpression = 'BooleanExpression';

export function isBooleanExpression(item: unknown): item is BooleanExpression {
    return reflection.isInstance(item, BooleanExpression);
}

export interface Conclusion extends AstNode {
    readonly $container: RWRule;
    readonly $type: 'Conclusion';
    outState: Array<Expression>
    ruleStart?: Expression
}

export const Conclusion = 'Conclusion';

export function isConclusion(item: unknown): item is Conclusion {
    return reflection.isInstance(item, Conclusion);
}

export interface Conjunction extends AstNode {
    readonly $container: Conjunction | Disjunction | Group | NamedArgument | Negation;
    readonly $type: 'Conjunction';
    left: Condition
    right: Condition
}

export const Conjunction = 'Conjunction';

export function isConjunction(item: unknown): item is Conjunction {
    return reflection.isInstance(item, Conjunction);
}

export interface Disjunction extends AstNode {
    readonly $container: Conjunction | Disjunction | Group | NamedArgument | Negation;
    readonly $type: 'Disjunction';
    left: Condition
    right: Condition
}

export const Disjunction = 'Disjunction';

export function isDisjunction(item: unknown): item is Disjunction {
    return reflection.isInstance(item, Disjunction);
}

export interface FieldMember extends AstNode {
    readonly $container: RuleOpening | SemanticEquivalence | SequenceLoop | SoSSpec | Struct | TypeReference;
    readonly $type: 'FieldMember';
    name: string
    type: TypeReference
}

export const FieldMember = 'FieldMember';

export function isFieldMember(item: unknown): item is FieldMember {
    return reflection.isInstance(item, FieldMember);
}

export interface Grammar extends AstNode {
    readonly $type: 'Grammar';
    definesHiddenTokens: boolean
    hiddenTokens: Array<Reference<AbstractRule>>
    imports: Array<GrammarImport>
    interfaces: Array<Interface>
    isDeclared: boolean
    name?: string
    rules: Array<AbstractRule>
    types: Array<Type>
    usedGrammars: Array<Reference<Grammar>>
}

export const Grammar = 'Grammar';

export function isGrammar(item: unknown): item is Grammar {
    return reflection.isInstance(item, Grammar);
}

export interface GrammarImport extends AstNode {
    readonly $container: Grammar;
    readonly $type: 'GrammarImport';
    path: string
}

export const GrammarImport = 'GrammarImport';

export function isGrammarImport(item: unknown): item is GrammarImport {
    return reflection.isInstance(item, GrammarImport);
}

export interface ImportStatement extends AstNode {
    readonly $container: SoSSpec;
    readonly $type: 'ImportStatement';
    importURI: string
}

export const ImportStatement = 'ImportStatement';

export function isImportStatement(item: unknown): item is ImportStatement {
    return reflection.isInstance(item, ImportStatement);
}

export interface InferredType extends AstNode {
    readonly $container: Action | ParserRule;
    readonly $type: 'InferredType';
    name: string
}

export const InferredType = 'InferredType';

export function isInferredType(item: unknown): item is InferredType {
    return reflection.isInstance(item, InferredType);
}

export interface Interface extends AstNode {
    readonly $container: Alternatives | Assignment | AtomType | CharacterRange | CrossReference | Grammar | Group | NegatedToken | ParserRule | TerminalAlternatives | TerminalGroup | TerminalRule | UnorderedGroup | UntilToken;
    readonly $type: 'Interface';
    attributes: Array<TypeAttribute>
    name: string
    superTypes: Array<Reference<AbstractType>>
}

export const Interface = 'Interface';

export function isInterface(item: unknown): item is Interface {
    return reflection.isInstance(item, Interface);
}

export interface LambdaParameter extends AstNode {
    readonly $type: 'LambdaParameter';
    name?: string
    type: TypeReference
}

export const LambdaParameter = 'LambdaParameter';

export function isLambdaParameter(item: unknown): item is LambdaParameter {
    return reflection.isInstance(item, LambdaParameter);
}

export interface LiteralCondition extends AstNode {
    readonly $container: Conjunction | Disjunction | Group | NamedArgument | Negation;
    readonly $type: 'LiteralCondition';
    true: boolean
}

export const LiteralCondition = 'LiteralCondition';

export function isLiteralCondition(item: unknown): item is LiteralCondition {
    return reflection.isInstance(item, LiteralCondition);
}

export interface MemberCall extends AstNode {
    readonly $container: BinaryExpression | Conclusion | MemberCall | SchedulingConstraint | SchedulingRule | SemanticEquivalence | SequenceLoop | UnaryExpression | VariableDeclaration;
    readonly $type: 'MemberCall';
    arguments: Array<Expression>
    element?: Reference<NamedElement>
    explicitOperationCall: boolean
    previous?: Expression
}

export const MemberCall = 'MemberCall';

export function isMemberCall(item: unknown): item is MemberCall {
    return reflection.isInstance(item, MemberCall);
}

export interface MethodMember extends AstNode {
    readonly $container: RuleOpening | SemanticEquivalence | SequenceLoop | SoSSpec | Struct | TypeReference;
    readonly $type: 'MethodMember';
    name: string
    parameters: Array<Parameter>
    returnType: TypeReference
}

export const MethodMember = 'MethodMember';

export function isMethodMember(item: unknown): item is MethodMember {
    return reflection.isInstance(item, MethodMember);
}

export interface NamedArgument extends AstNode {
    readonly $container: RuleCall;
    readonly $type: 'NamedArgument';
    calledByName: boolean
    parameter?: Reference<Parameter>
    value: Condition
}

export const NamedArgument = 'NamedArgument';

export function isNamedArgument(item: unknown): item is NamedArgument {
    return reflection.isInstance(item, NamedArgument);
}

export interface Negation extends AstNode {
    readonly $container: Conjunction | Disjunction | Group | NamedArgument | Negation;
    readonly $type: 'Negation';
    value: Condition
}

export const Negation = 'Negation';

export function isNegation(item: unknown): item is Negation {
    return reflection.isInstance(item, Negation);
}

export interface NilExpression extends AstNode {
    readonly $container: BinaryExpression | Conclusion | MemberCall | SchedulingConstraint | SchedulingRule | SemanticEquivalence | SequenceLoop | UnaryExpression | VariableDeclaration;
    readonly $type: 'NilExpression';
    value: 'nil'
}

export const NilExpression = 'NilExpression';

export function isNilExpression(item: unknown): item is NilExpression {
    return reflection.isInstance(item, NilExpression);
}

export interface NumberExpression extends AstNode {
    readonly $container: BinaryExpression | Conclusion | MemberCall | SchedulingConstraint | SchedulingRule | SemanticEquivalence | SequenceLoop | UnaryExpression | VariableDeclaration;
    readonly $type: 'NumberExpression';
    value: number
}

export const NumberExpression = 'NumberExpression';

export function isNumberExpression(item: unknown): item is NumberExpression {
    return reflection.isInstance(item, NumberExpression);
}

export interface Parameter extends AstNode {
    readonly $container: MethodMember | ParserRule;
    readonly $type: 'Parameter';
    name: string
}

export const Parameter = 'Parameter';

export function isParameter(item: unknown): item is Parameter {
    return reflection.isInstance(item, Parameter);
}

export interface ParameterReference extends AstNode {
    readonly $container: Conjunction | Disjunction | Group | NamedArgument | Negation;
    readonly $type: 'ParameterReference';
    parameter: Reference<Parameter>
}

export const ParameterReference = 'ParameterReference';

export function isParameterReference(item: unknown): item is ParameterReference {
    return reflection.isInstance(item, ParameterReference);
}

export interface ParserRule extends AstNode {
    readonly $container: Alternatives | Assignment | AtomType | CharacterRange | CrossReference | Grammar | Group | NegatedToken | ParserRule | TerminalAlternatives | TerminalGroup | TerminalRule | UnorderedGroup | UntilToken;
    readonly $type: 'ParserRule';
    dataType?: PrimitiveType
    definesHiddenTokens: boolean
    definition: AbstractElement
    entry: boolean
    fragment: boolean
    hiddenTokens: Array<Reference<AbstractRule>>
    inferredType?: InferredType
    name: string
    parameters: Array<Parameter>
    returnType?: Reference<AbstractType>
    wildcard: boolean
}

export const ParserRule = 'ParserRule';

export function isParserRule(item: unknown): item is ParserRule {
    return reflection.isInstance(item, ParserRule);
}

export interface QueryRule extends AstNode {
    readonly $container: RuleOpening;
    readonly $type: 'QueryRule';
    premise: Array<SemanticEquivalence>
}

export const QueryRule = 'QueryRule';

export function isQueryRule(item: unknown): item is QueryRule {
    return reflection.isInstance(item, QueryRule);
}

export interface ReturnType extends AstNode {
    readonly $container: TerminalRule;
    readonly $type: 'ReturnType';
    name: PrimitiveType | string
}

export const ReturnType = 'ReturnType';

export function isReturnType(item: unknown): item is ReturnType {
    return reflection.isInstance(item, ReturnType);
}

export interface RuleOpening extends AstNode {
    readonly $container: RuleOpening | SemanticEquivalence | SequenceLoop | SoSSpec | Struct | TypeReference;
    readonly $type: 'RuleOpening';
    isNonAtomic: boolean
    name?: string
    onRule: Reference<ParserRule>
    rules: Array<QueryRule | RWRule | SchedulingRule>
    runtimeState: Array<NamedElement>
}

export const RuleOpening = 'RuleOpening';

export function isRuleOpening(item: unknown): item is RuleOpening {
    return reflection.isInstance(item, RuleOpening);
}

export interface RWRule extends AstNode {
    readonly $container: RuleOpening | SemanticEquivalence | SequenceLoop | SoSSpec | Struct | TypeReference;
    readonly $type: 'RWRule';
    conclusion: Conclusion
    name: string
    premise: Array<SemanticEquivalence>
}

export const RWRule = 'RWRule';

export function isRWRule(item: unknown): item is RWRule {
    return reflection.isInstance(item, RWRule);
}

export interface SchedulingConstraint extends AstNode {
    readonly $container: SchedulingRule;
    readonly $type: 'SchedulingConstraint';
    left: Expression
    operator: 'coincides_with' | 'precedes'
    right: Expression
}

export const SchedulingConstraint = 'SchedulingConstraint';

export function isSchedulingConstraint(item: unknown): item is SchedulingConstraint {
    return reflection.isInstance(item, SchedulingConstraint);
}

export interface SchedulingRule extends AstNode {
    readonly $container: RuleOpening;
    readonly $type: 'SchedulingRule';
    condition?: Expression
    constraint: SchedulingConstraint
    loop?: SequenceLoop
}

export const SchedulingRule = 'SchedulingRule';

export function isSchedulingRule(item: unknown): item is SchedulingRule {
    return reflection.isInstance(item, SchedulingRule);
}

export interface SemanticEquivalence extends AstNode {
    readonly $container: QueryRule | RWRule;
    readonly $type: 'SemanticEquivalence';
    left?: Expression
    operator?: '->'
    right?: Expression | NamedElement
}

export const SemanticEquivalence = 'SemanticEquivalence';

export function isSemanticEquivalence(item: unknown): item is SemanticEquivalence {
    return reflection.isInstance(item, SemanticEquivalence);
}

export interface SequenceLoop extends AstNode {
    readonly $container: SchedulingRule;
    readonly $type: 'SequenceLoop';
    itVar: NamedElement
    lowerBound: number
    upperBound: Expression
}

export const SequenceLoop = 'SequenceLoop';

export function isSequenceLoop(item: unknown): item is SequenceLoop {
    return reflection.isInstance(item, SequenceLoop);
}

export interface SoSPrimitiveType extends AstNode {
    readonly $container: RuleOpening | SemanticEquivalence | SequenceLoop | SoSSpec | Struct | TypeReference;
    readonly $type: 'SoSPrimitiveType';
    name: 'boolean' | 'event' | 'number' | 'string' | 'void'
}

export const SoSPrimitiveType = 'SoSPrimitiveType';

export function isSoSPrimitiveType(item: unknown): item is SoSPrimitiveType {
    return reflection.isInstance(item, SoSPrimitiveType);
}

export interface SoSSpec extends AstNode {
    readonly $type: 'SoSSpec';
    imports: ImportStatement
    name: string
    rtdAndRules: Array<RuleOpening>
}

export const SoSSpec = 'SoSSpec';

export function isSoSSpec(item: unknown): item is SoSSpec {
    return reflection.isInstance(item, SoSSpec);
}

export interface StringExpression extends AstNode {
    readonly $container: BinaryExpression | Conclusion | MemberCall | SchedulingConstraint | SchedulingRule | SemanticEquivalence | SequenceLoop | UnaryExpression | VariableDeclaration;
    readonly $type: 'StringExpression';
    value: string
}

export const StringExpression = 'StringExpression';

export function isStringExpression(item: unknown): item is StringExpression {
    return reflection.isInstance(item, StringExpression);
}

export interface Struct extends AstNode {
    readonly $container: RuleOpening | SemanticEquivalence | SequenceLoop | SoSSpec | Struct | TypeReference;
    readonly $type: 'Struct';
    members: Array<FieldMember>
    name: string
    superClass?: Reference<Struct>
}

export const Struct = 'Struct';

export function isStruct(item: unknown): item is Struct {
    return reflection.isInstance(item, Struct);
}

export interface TemporaryVariable extends AstNode {
    readonly $container: RuleOpening | SemanticEquivalence | SequenceLoop | SoSSpec | Struct | TypeReference;
    readonly $type: 'TemporaryVariable';
    name: string
    type?: TypeReference
}

export const TemporaryVariable = 'TemporaryVariable';

export function isTemporaryVariable(item: unknown): item is TemporaryVariable {
    return reflection.isInstance(item, TemporaryVariable);
}

export interface TerminalRule extends AstNode {
    readonly $container: Alternatives | Assignment | AtomType | CharacterRange | CrossReference | Grammar | Group | NegatedToken | ParserRule | TerminalAlternatives | TerminalGroup | TerminalRule | UnorderedGroup | UntilToken;
    readonly $type: 'TerminalRule';
    definition: AbstractElement
    fragment: boolean
    hidden: boolean
    name: string
    type?: ReturnType
}

export const TerminalRule = 'TerminalRule';

export function isTerminalRule(item: unknown): item is TerminalRule {
    return reflection.isInstance(item, TerminalRule);
}

export interface Type extends AstNode {
    readonly $container: Alternatives | Assignment | AtomType | CharacterRange | CrossReference | Grammar | Group | NegatedToken | ParserRule | TerminalAlternatives | TerminalGroup | TerminalRule | UnorderedGroup | UntilToken;
    readonly $type: 'Type';
    name: string
    typeAlternatives: Array<AtomType>
}

export const Type = 'Type';

export function isType(item: unknown): item is Type {
    return reflection.isInstance(item, Type);
}

export interface TypeAttribute extends AstNode {
    readonly $container: Interface;
    readonly $type: 'TypeAttribute';
    isOptional: boolean
    name: FeatureName
    typeAlternatives: Array<AtomType>
}

export const TypeAttribute = 'TypeAttribute';

export function isTypeAttribute(item: unknown): item is TypeAttribute {
    return reflection.isInstance(item, TypeAttribute);
}

export interface TypeReference extends AstNode {
    readonly $container: FieldMember | LambdaParameter | MethodMember | TemporaryVariable | VariableDeclaration;
    readonly $type: 'TypeReference';
    primitive?: SoSPrimitiveType
    reference?: Reference<AbstractRule>
}

export const TypeReference = 'TypeReference';

export function isTypeReference(item: unknown): item is TypeReference {
    return reflection.isInstance(item, TypeReference);
}

export interface UnaryExpression extends AstNode {
    readonly $container: BinaryExpression | Conclusion | MemberCall | SchedulingConstraint | SchedulingRule | SemanticEquivalence | SequenceLoop | UnaryExpression | VariableDeclaration;
    readonly $type: 'UnaryExpression';
    operator: '!' | '+' | '-'
    value: Expression
}

export const UnaryExpression = 'UnaryExpression';

export function isUnaryExpression(item: unknown): item is UnaryExpression {
    return reflection.isInstance(item, UnaryExpression);
}

export interface VariableDeclaration extends AstNode {
    readonly $container: RuleOpening | SemanticEquivalence | SequenceLoop | SoSSpec | Struct | TypeReference;
    readonly $type: 'VariableDeclaration';
    assignment: boolean
    name: string
    type?: TypeReference
    value?: Expression
}

export const VariableDeclaration = 'VariableDeclaration';

export function isVariableDeclaration(item: unknown): item is VariableDeclaration {
    return reflection.isInstance(item, VariableDeclaration);
}

export interface Action extends AbstractElement {
    readonly $container: Alternatives | Assignment | AtomType | CharacterRange | CrossReference | Grammar | Group | NegatedToken | ParserRule | TerminalAlternatives | TerminalGroup | TerminalRule | UnorderedGroup | UntilToken;
    readonly $type: 'Action';
    feature?: FeatureName
    inferredType?: InferredType
    operator?: '+=' | '='
    type?: Reference<AbstractType>
}

export const Action = 'Action';

export function isAction(item: unknown): item is Action {
    return reflection.isInstance(item, Action);
}

export interface Alternatives extends AbstractElement {
    readonly $container: Alternatives | Assignment | AtomType | CharacterRange | CrossReference | Grammar | Group | NegatedToken | ParserRule | TerminalAlternatives | TerminalGroup | TerminalRule | UnorderedGroup | UntilToken;
    readonly $type: 'Alternatives';
    elements: Array<AbstractElement>
}

export const Alternatives = 'Alternatives';

export function isAlternatives(item: unknown): item is Alternatives {
    return reflection.isInstance(item, Alternatives);
}

export interface Assignment extends AbstractElement {
    readonly $container: Alternatives | Assignment | AtomType | CharacterRange | CrossReference | Grammar | Group | NegatedToken | ParserRule | TerminalAlternatives | TerminalGroup | TerminalRule | UnorderedGroup | UntilToken;
    readonly $type: 'Assignment';
    feature: FeatureName
    operator: '+=' | '=' | '?='
    terminal: AbstractElement
}

export const Assignment = 'Assignment';

export function isAssignment(item: unknown): item is Assignment {
    return reflection.isInstance(item, Assignment);
}

export interface CharacterRange extends AbstractElement {
    readonly $container: Alternatives | Assignment | AtomType | CharacterRange | CrossReference | Grammar | Group | NegatedToken | ParserRule | TerminalAlternatives | TerminalGroup | TerminalRule | UnorderedGroup | UntilToken;
    readonly $type: 'CharacterRange';
    left: Keyword
    right?: Keyword
}

export const CharacterRange = 'CharacterRange';

export function isCharacterRange(item: unknown): item is CharacterRange {
    return reflection.isInstance(item, CharacterRange);
}

export interface CrossReference extends AbstractElement {
    readonly $container: Alternatives | Assignment | AtomType | CharacterRange | CrossReference | Grammar | Group | NegatedToken | ParserRule | TerminalAlternatives | TerminalGroup | TerminalRule | UnorderedGroup | UntilToken;
    readonly $type: 'CrossReference';
    deprecatedSyntax: boolean
    terminal?: AbstractElement
    type: Reference<AbstractType>
}

export const CrossReference = 'CrossReference';

export function isCrossReference(item: unknown): item is CrossReference {
    return reflection.isInstance(item, CrossReference);
}

export interface Group extends AbstractElement {
    readonly $container: Alternatives | Assignment | AtomType | CharacterRange | CrossReference | Grammar | Group | NegatedToken | ParserRule | TerminalAlternatives | TerminalGroup | TerminalRule | UnorderedGroup | UntilToken;
    readonly $type: 'Group';
    elements: Array<AbstractElement>
    guardCondition?: Condition
}

export const Group = 'Group';

export function isGroup(item: unknown): item is Group {
    return reflection.isInstance(item, Group);
}

export interface Keyword extends AbstractElement {
    readonly $container: Alternatives | Assignment | AtomType | CharacterRange | CrossReference | Grammar | Group | NegatedToken | ParserRule | TerminalAlternatives | TerminalGroup | TerminalRule | UnorderedGroup | UntilToken;
    readonly $type: 'Keyword';
    value: string
}

export const Keyword = 'Keyword';

export function isKeyword(item: unknown): item is Keyword {
    return reflection.isInstance(item, Keyword);
}

export interface NegatedToken extends AbstractElement {
    readonly $container: Alternatives | Assignment | AtomType | CharacterRange | CrossReference | Grammar | Group | NegatedToken | ParserRule | TerminalAlternatives | TerminalGroup | TerminalRule | UnorderedGroup | UntilToken;
    readonly $type: 'NegatedToken';
    terminal: AbstractElement
}

export const NegatedToken = 'NegatedToken';

export function isNegatedToken(item: unknown): item is NegatedToken {
    return reflection.isInstance(item, NegatedToken);
}

export interface RegexToken extends AbstractElement {
    readonly $container: Alternatives | Assignment | AtomType | CharacterRange | CrossReference | Grammar | Group | NegatedToken | ParserRule | TerminalAlternatives | TerminalGroup | TerminalRule | UnorderedGroup | UntilToken;
    readonly $type: 'RegexToken';
    regex: string
}

export const RegexToken = 'RegexToken';

export function isRegexToken(item: unknown): item is RegexToken {
    return reflection.isInstance(item, RegexToken);
}

export interface RuleCall extends AbstractElement {
    readonly $container: Alternatives | Assignment | AtomType | CharacterRange | CrossReference | Grammar | Group | NegatedToken | ParserRule | TerminalAlternatives | TerminalGroup | TerminalRule | UnorderedGroup | UntilToken;
    readonly $type: 'RuleCall';
    arguments: Array<NamedArgument>
    rule: Reference<AbstractRule>
}

export const RuleCall = 'RuleCall';

export function isRuleCall(item: unknown): item is RuleCall {
    return reflection.isInstance(item, RuleCall);
}

export interface TerminalAlternatives extends AbstractElement {
    readonly $container: Alternatives | Assignment | AtomType | CharacterRange | CrossReference | Grammar | Group | NegatedToken | ParserRule | TerminalAlternatives | TerminalGroup | TerminalRule | UnorderedGroup | UntilToken;
    readonly $type: 'TerminalAlternatives';
    elements: Array<AbstractElement>
}

export const TerminalAlternatives = 'TerminalAlternatives';

export function isTerminalAlternatives(item: unknown): item is TerminalAlternatives {
    return reflection.isInstance(item, TerminalAlternatives);
}

export interface TerminalGroup extends AbstractElement {
    readonly $container: Alternatives | Assignment | AtomType | CharacterRange | CrossReference | Grammar | Group | NegatedToken | ParserRule | TerminalAlternatives | TerminalGroup | TerminalRule | UnorderedGroup | UntilToken;
    readonly $type: 'TerminalGroup';
    elements: Array<AbstractElement>
}

export const TerminalGroup = 'TerminalGroup';

export function isTerminalGroup(item: unknown): item is TerminalGroup {
    return reflection.isInstance(item, TerminalGroup);
}

export interface TerminalRuleCall extends AbstractElement {
    readonly $container: Alternatives | Assignment | AtomType | CharacterRange | CrossReference | Grammar | Group | NegatedToken | ParserRule | TerminalAlternatives | TerminalGroup | TerminalRule | UnorderedGroup | UntilToken;
    readonly $type: 'TerminalRuleCall';
    rule: Reference<TerminalRule>
}

export const TerminalRuleCall = 'TerminalRuleCall';

export function isTerminalRuleCall(item: unknown): item is TerminalRuleCall {
    return reflection.isInstance(item, TerminalRuleCall);
}

export interface UnorderedGroup extends AbstractElement {
    readonly $container: Alternatives | Assignment | AtomType | CharacterRange | CrossReference | Grammar | Group | NegatedToken | ParserRule | TerminalAlternatives | TerminalGroup | TerminalRule | UnorderedGroup | UntilToken;
    readonly $type: 'UnorderedGroup';
    elements: Array<AbstractElement>
}

export const UnorderedGroup = 'UnorderedGroup';

export function isUnorderedGroup(item: unknown): item is UnorderedGroup {
    return reflection.isInstance(item, UnorderedGroup);
}

export interface UntilToken extends AbstractElement {
    readonly $container: Alternatives | Assignment | AtomType | CharacterRange | CrossReference | Grammar | Group | NegatedToken | ParserRule | TerminalAlternatives | TerminalGroup | TerminalRule | UnorderedGroup | UntilToken;
    readonly $type: 'UntilToken';
    terminal: AbstractElement
}

export const UntilToken = 'UntilToken';

export function isUntilToken(item: unknown): item is UntilToken {
    return reflection.isInstance(item, UntilToken);
}

export interface Wildcard extends AbstractElement {
    readonly $container: Alternatives | Assignment | AtomType | CharacterRange | CrossReference | Grammar | Group | NegatedToken | ParserRule | TerminalAlternatives | TerminalGroup | TerminalRule | UnorderedGroup | UntilToken;
    readonly $type: 'Wildcard';
}

export const Wildcard = 'Wildcard';

export function isWildcard(item: unknown): item is Wildcard {
    return reflection.isInstance(item, Wildcard);
}

export interface StructuralOperationalSemanticsAstType {
    AbstractElement: AbstractElement
    AbstractRule: AbstractRule
    AbstractType: AbstractType
    Action: Action
    Alternatives: Alternatives
    Assignment: Assignment
    AtomType: AtomType
    BinaryExpression: BinaryExpression
    BooleanExpression: BooleanExpression
    CharacterRange: CharacterRange
    Conclusion: Conclusion
    Condition: Condition
    Conjunction: Conjunction
    CrossReference: CrossReference
    Disjunction: Disjunction
    Expression: Expression
    FieldMember: FieldMember
    Grammar: Grammar
    GrammarImport: GrammarImport
    Group: Group
    ImportStatement: ImportStatement
    InferredType: InferredType
    Interface: Interface
    Keyword: Keyword
    LambdaParameter: LambdaParameter
    LiteralCondition: LiteralCondition
    MemberCall: MemberCall
    MethodMember: MethodMember
    NamedArgument: NamedArgument
    NamedElement: NamedElement
    NegatedToken: NegatedToken
    Negation: Negation
    NilExpression: NilExpression
    NumberExpression: NumberExpression
    Parameter: Parameter
    ParameterReference: ParameterReference
    ParserRule: ParserRule
    QueryRule: QueryRule
    RWRule: RWRule
    RegexToken: RegexToken
    ReturnType: ReturnType
    RuleCall: RuleCall
    RuleOpening: RuleOpening
    SchedulingConstraint: SchedulingConstraint
    SchedulingRule: SchedulingRule
    SemanticEquivalence: SemanticEquivalence
    SequenceLoop: SequenceLoop
    SoSPrimitiveType: SoSPrimitiveType
    SoSSpec: SoSSpec
    StringExpression: StringExpression
    Struct: Struct
    TemporaryVariable: TemporaryVariable
    TerminalAlternatives: TerminalAlternatives
    TerminalGroup: TerminalGroup
    TerminalRule: TerminalRule
    TerminalRuleCall: TerminalRuleCall
    Type: Type
    TypeAttribute: TypeAttribute
    TypeReference: TypeReference
    UnaryExpression: UnaryExpression
    UnorderedGroup: UnorderedGroup
    UntilToken: UntilToken
    VariableDeclaration: VariableDeclaration
    Wildcard: Wildcard
}

export class StructuralOperationalSemanticsAstReflection extends AbstractAstReflection {

    getAllTypes(): string[] {
        return ['AbstractElement', 'AbstractRule', 'AbstractType', 'Action', 'Alternatives', 'Assignment', 'AtomType', 'BinaryExpression', 'BooleanExpression', 'CharacterRange', 'Conclusion', 'Condition', 'Conjunction', 'CrossReference', 'Disjunction', 'Expression', 'FieldMember', 'Grammar', 'GrammarImport', 'Group', 'ImportStatement', 'InferredType', 'Interface', 'Keyword', 'LambdaParameter', 'LiteralCondition', 'MemberCall', 'MethodMember', 'NamedArgument', 'NamedElement', 'NegatedToken', 'Negation', 'NilExpression', 'NumberExpression', 'Parameter', 'ParameterReference', 'ParserRule', 'QueryRule', 'RWRule', 'RegexToken', 'ReturnType', 'RuleCall', 'RuleOpening', 'SchedulingConstraint', 'SchedulingRule', 'SemanticEquivalence', 'SequenceLoop', 'SoSPrimitiveType', 'SoSSpec', 'StringExpression', 'Struct', 'TemporaryVariable', 'TerminalAlternatives', 'TerminalGroup', 'TerminalRule', 'TerminalRuleCall', 'Type', 'TypeAttribute', 'TypeReference', 'UnaryExpression', 'UnorderedGroup', 'UntilToken', 'VariableDeclaration', 'Wildcard'];
    }

    protected override computeIsSubtype(subtype: string, supertype: string): boolean {
        switch (subtype) {
            case BinaryExpression:
            case BooleanExpression:
            case MemberCall:
            case NilExpression:
            case NumberExpression:
            case StringExpression:
            case UnaryExpression: {
                return this.isSubtype(Expression, supertype);
            }
            case Conjunction:
            case Disjunction:
            case LiteralCondition:
            case Negation:
            case ParameterReference: {
                return this.isSubtype(Condition, supertype);
            }
            case FieldMember:
            case MethodMember:
            case RuleOpening:
            case RWRule:
            case SoSPrimitiveType:
            case Struct:
            case TemporaryVariable:
            case VariableDeclaration: {
                return this.isSubtype(NamedElement, supertype);
            }
            case Interface:
            case Type: {
                return this.isSubtype(AbstractType, supertype);
            }
            case ParserRule: {
                return this.isSubtype(AbstractRule, supertype) || this.isSubtype(AbstractType, supertype);
            }
            case TerminalRule: {
                return this.isSubtype(AbstractRule, supertype);
            }
            case Action: {
                return this.isSubtype(AbstractElement, supertype) || this.isSubtype(AbstractType, supertype);
            }
            case Alternatives:
            case Assignment:
            case CharacterRange:
            case CrossReference:
            case Group:
            case Keyword:
            case NegatedToken:
            case RegexToken:
            case RuleCall:
            case TerminalAlternatives:
            case TerminalGroup:
            case TerminalRuleCall:
            case UnorderedGroup:
            case UntilToken:
            case Wildcard: {
                return this.isSubtype(AbstractElement, supertype);
            }
            default: {
                return false;
            }
        }
    }

    getReferenceType(refInfo: ReferenceInfo): string {
        const referenceId = `${refInfo.container.$type}:${refInfo.property}`;
        switch (referenceId) {
            case 'Action:type':
            case 'AtomType:refType':
            case 'CrossReference:type':
            case 'Interface:superTypes':
            case 'ParserRule:returnType': {
                return AbstractType;
            }
            case 'Grammar:hiddenTokens':
            case 'ParserRule:hiddenTokens':
            case 'RuleCall:rule':
            case 'TypeReference:reference': {
                return AbstractRule;
            }
            case 'Grammar:usedGrammars': {
                return Grammar;
            }
            case 'MemberCall:element': {
                return NamedElement;
            }
            case 'NamedArgument:parameter':
            case 'ParameterReference:parameter': {
                return Parameter;
            }
            case 'RuleOpening:onRule': {
                return ParserRule;
            }
            case 'Struct:superClass': {
                return Struct;
            }
            case 'TerminalRuleCall:rule': {
                return TerminalRule;
            }
            default: {
                throw new Error(`${referenceId} is not a valid reference id.`);
            }
        }
    }

    getTypeMetaData(type: string): TypeMetaData {
        switch (type) {
            case 'AtomType': {
                return {
                    name: 'AtomType',
                    mandatory: [
                        { name: 'isArray', type: 'boolean' },
                        { name: 'isRef', type: 'boolean' }
                    ]
                };
            }
            case 'BooleanExpression': {
                return {
                    name: 'BooleanExpression',
                    mandatory: [
                        { name: 'value', type: 'boolean' }
                    ]
                };
            }
            case 'Conclusion': {
                return {
                    name: 'Conclusion',
                    mandatory: [
                        { name: 'outState', type: 'array' }
                    ]
                };
            }
            case 'Grammar': {
                return {
                    name: 'Grammar',
                    mandatory: [
                        { name: 'definesHiddenTokens', type: 'boolean' },
                        { name: 'hiddenTokens', type: 'array' },
                        { name: 'imports', type: 'array' },
                        { name: 'interfaces', type: 'array' },
                        { name: 'isDeclared', type: 'boolean' },
                        { name: 'rules', type: 'array' },
                        { name: 'types', type: 'array' },
                        { name: 'usedGrammars', type: 'array' }
                    ]
                };
            }
            case 'Interface': {
                return {
                    name: 'Interface',
                    mandatory: [
                        { name: 'attributes', type: 'array' },
                        { name: 'superTypes', type: 'array' }
                    ]
                };
            }
            case 'LiteralCondition': {
                return {
                    name: 'LiteralCondition',
                    mandatory: [
                        { name: 'true', type: 'boolean' }
                    ]
                };
            }
            case 'MemberCall': {
                return {
                    name: 'MemberCall',
                    mandatory: [
                        { name: 'arguments', type: 'array' },
                        { name: 'explicitOperationCall', type: 'boolean' }
                    ]
                };
            }
            case 'MethodMember': {
                return {
                    name: 'MethodMember',
                    mandatory: [
                        { name: 'parameters', type: 'array' }
                    ]
                };
            }
            case 'NamedArgument': {
                return {
                    name: 'NamedArgument',
                    mandatory: [
                        { name: 'calledByName', type: 'boolean' }
                    ]
                };
            }
            case 'ParserRule': {
                return {
                    name: 'ParserRule',
                    mandatory: [
                        { name: 'definesHiddenTokens', type: 'boolean' },
                        { name: 'entry', type: 'boolean' },
                        { name: 'fragment', type: 'boolean' },
                        { name: 'hiddenTokens', type: 'array' },
                        { name: 'parameters', type: 'array' },
                        { name: 'wildcard', type: 'boolean' }
                    ]
                };
            }
            case 'QueryRule': {
                return {
                    name: 'QueryRule',
                    mandatory: [
                        { name: 'premise', type: 'array' }
                    ]
                };
            }
            case 'RuleOpening': {
                return {
                    name: 'RuleOpening',
                    mandatory: [
                        { name: 'isNonAtomic', type: 'boolean' },
                        { name: 'rules', type: 'array' },
                        { name: 'runtimeState', type: 'array' }
                    ]
                };
            }
            case 'RWRule': {
                return {
                    name: 'RWRule',
                    mandatory: [
                        { name: 'premise', type: 'array' }
                    ]
                };
            }
            case 'SoSSpec': {
                return {
                    name: 'SoSSpec',
                    mandatory: [
                        { name: 'rtdAndRules', type: 'array' }
                    ]
                };
            }
            case 'Struct': {
                return {
                    name: 'Struct',
                    mandatory: [
                        { name: 'members', type: 'array' }
                    ]
                };
            }
            case 'TerminalRule': {
                return {
                    name: 'TerminalRule',
                    mandatory: [
                        { name: 'fragment', type: 'boolean' },
                        { name: 'hidden', type: 'boolean' }
                    ]
                };
            }
            case 'Type': {
                return {
                    name: 'Type',
                    mandatory: [
                        { name: 'typeAlternatives', type: 'array' }
                    ]
                };
            }
            case 'TypeAttribute': {
                return {
                    name: 'TypeAttribute',
                    mandatory: [
                        { name: 'isOptional', type: 'boolean' },
                        { name: 'typeAlternatives', type: 'array' }
                    ]
                };
            }
            case 'VariableDeclaration': {
                return {
                    name: 'VariableDeclaration',
                    mandatory: [
                        { name: 'assignment', type: 'boolean' }
                    ]
                };
            }
            case 'Alternatives': {
                return {
                    name: 'Alternatives',
                    mandatory: [
                        { name: 'elements', type: 'array' }
                    ]
                };
            }
            case 'CrossReference': {
                return {
                    name: 'CrossReference',
                    mandatory: [
                        { name: 'deprecatedSyntax', type: 'boolean' }
                    ]
                };
            }
            case 'Group': {
                return {
                    name: 'Group',
                    mandatory: [
                        { name: 'elements', type: 'array' }
                    ]
                };
            }
            case 'RuleCall': {
                return {
                    name: 'RuleCall',
                    mandatory: [
                        { name: 'arguments', type: 'array' }
                    ]
                };
            }
            case 'TerminalAlternatives': {
                return {
                    name: 'TerminalAlternatives',
                    mandatory: [
                        { name: 'elements', type: 'array' }
                    ]
                };
            }
            case 'TerminalGroup': {
                return {
                    name: 'TerminalGroup',
                    mandatory: [
                        { name: 'elements', type: 'array' }
                    ]
                };
            }
            case 'UnorderedGroup': {
                return {
                    name: 'UnorderedGroup',
                    mandatory: [
                        { name: 'elements', type: 'array' }
                    ]
                };
            }
            default: {
                return {
                    name: type,
                    mandatory: []
                };
            }
        }
    }
}

export const reflection = new StructuralOperationalSemanticsAstReflection();
