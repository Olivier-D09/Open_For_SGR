/******************************************************************************
 * This file was generated by langium-cli 1.0.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable */
import { AstNode, AbstractAstReflection, Reference, ReferenceInfo, TypeMetaData } from 'langium';

export type Expr = If | Plus | VarRef;

export const Expr = 'Expr';

export function isExpr(item: unknown): item is Expr {
    return reflection.isInstance(item, Expr);
}

export type Statement = Assignment | Bloc | Expr | ParallelBloc | VarDecl;

export const Statement = 'Statement';

export function isStatement(item: unknown): item is Statement {
    return reflection.isInstance(item, Statement);
}

export interface Assignment extends AstNode {
    readonly $container: Assignment | Bloc | If | Model | ParallelBloc | Plus;
    readonly $type: 'Assignment';
    left: Reference<VarDecl>
    right: Expr
}

export const Assignment = 'Assignment';

export function isAssignment(item: unknown): item is Assignment {
    return reflection.isInstance(item, Assignment);
}

export interface Bloc extends AstNode {
    readonly $container: Assignment | Bloc | If | Model | ParallelBloc | Plus;
    readonly $type: 'Bloc';
    statements: Array<Statement>
}

export const Bloc = 'Bloc';

export function isBloc(item: unknown): item is Bloc {
    return reflection.isInstance(item, Bloc);
}

export interface If extends AstNode {
    readonly $container: Assignment | Bloc | If | Model | ParallelBloc | Plus;
    readonly $type: 'If';
    cond: VarRef
    else?: Bloc
    then: Bloc
}

export const If = 'If';

export function isIf(item: unknown): item is If {
    return reflection.isInstance(item, If);
}

export interface Model extends AstNode {
    readonly $type: 'Model';
    statements: Array<Statement>
}

export const Model = 'Model';

export function isModel(item: unknown): item is Model {
    return reflection.isInstance(item, Model);
}

export interface ParallelBloc extends AstNode {
    readonly $container: Assignment | Bloc | If | Model | ParallelBloc | Plus;
    readonly $type: 'ParallelBloc';
    statements: Array<Statement>
}

export const ParallelBloc = 'ParallelBloc';

export function isParallelBloc(item: unknown): item is ParallelBloc {
    return reflection.isInstance(item, ParallelBloc);
}

export interface Plus extends AstNode {
    readonly $container: Assignment | Bloc | If | Model | ParallelBloc | Plus;
    readonly $type: 'Plus';
    left: VarRef
    right: Expr
}

export const Plus = 'Plus';

export function isPlus(item: unknown): item is Plus {
    return reflection.isInstance(item, Plus);
}

export interface VarDecl extends AstNode {
    readonly $container: Assignment | Bloc | If | Model | ParallelBloc | Plus;
    readonly $type: 'VarDecl';
    initialValue?: number
    name: string
}

export const VarDecl = 'VarDecl';

export function isVarDecl(item: unknown): item is VarDecl {
    return reflection.isInstance(item, VarDecl);
}

export interface VarRef extends AstNode {
    readonly $container: Assignment | Bloc | If | Model | ParallelBloc | Plus;
    readonly $type: 'VarRef';
    ref: Reference<VarDecl>
}

export const VarRef = 'VarRef';

export function isVarRef(item: unknown): item is VarRef {
    return reflection.isInstance(item, VarRef);
}

export interface SimpleLAstType {
    Assignment: Assignment
    Bloc: Bloc
    Expr: Expr
    If: If
    Model: Model
    ParallelBloc: ParallelBloc
    Plus: Plus
    Statement: Statement
    VarDecl: VarDecl
    VarRef: VarRef
}

export class SimpleLAstReflection extends AbstractAstReflection {

    getAllTypes(): string[] {
        return ['Assignment', 'Bloc', 'Expr', 'If', 'Model', 'ParallelBloc', 'Plus', 'Statement', 'VarDecl', 'VarRef'];
    }

    protected override computeIsSubtype(subtype: string, supertype: string): boolean {
        switch (subtype) {
            case Assignment:
            case Bloc:
            case ParallelBloc:
            case VarDecl:
            case Expr: {
                return this.isSubtype(Statement, supertype);
            }
            case If:
            case Plus:
            case VarRef: {
                return this.isSubtype(Expr, supertype);
            }
            default: {
                return false;
            }
        }
    }

    getReferenceType(refInfo: ReferenceInfo): string {
        const referenceId = `${refInfo.container.$type}:${refInfo.property}`;
        switch (referenceId) {
            case 'Assignment:left':
            case 'VarRef:ref': {
                return VarDecl;
            }
            default: {
                throw new Error(`${referenceId} is not a valid reference id.`);
            }
        }
    }

    getTypeMetaData(type: string): TypeMetaData {
        switch (type) {
            case 'Bloc': {
                return {
                    name: 'Bloc',
                    mandatory: [
                        { name: 'statements', type: 'array' }
                    ]
                };
            }
            case 'Model': {
                return {
                    name: 'Model',
                    mandatory: [
                        { name: 'statements', type: 'array' }
                    ]
                };
            }
            case 'ParallelBloc': {
                return {
                    name: 'ParallelBloc',
                    mandatory: [
                        { name: 'statements', type: 'array' }
                    ]
                };
            }
            default: {
                return {
                    name: type,
                    mandatory: []
                };
            }
        }
    }
}

export const reflection = new SimpleLAstReflection();
