testSimpleL
import "testSoSLang/src/language-server/simple-l.langium"



open non atomic rule Model { 

    sched { startEvaluation coincides_with statements.first().startEvaluation}
    sched { finishEvaluation coincides_with statements.last().finishEvaluation}
    sched foreach i in [0; statements.length()[ {
        statements.at(i).finishEvaluation precedes statements.at(i+1).startEvaluation 
    }
}

open non atomic rule Bloc {

    //var test: Statement

    sched { startEvaluation coincides_with statements.first().startEvaluation}
    sched { finishEvaluation coincides_with statements.last().finishEvaluation}
    sched foreach i in [0; statements.length()[ {
        statements.at(i).finishEvaluation precedes statements.at(i+1).startEvaluation 
    }
}

open non atomic rule VarDecl {

    var currentValue:number = initialValue;

      
    --------------------------- evaluate
     <this,σ> ~> currentValue;

}

open atomic rule VarRef {
    
      <ref,σ> -> value:number
    --------------------------- evaluate
         <this,σ> ~> value;

}

open atomic rule Plus {
   
    <right,σ> -> n2:number ; <left,σ> -> n1:number
    ---------------------------------------------- evaluate
                 <this,σ> ~> n1 + n2 ;
}


open non atomic rule If {
    sched {startEvaluation coincides_with evalCond}
    sched {evalCond precedes (condTrue xor condFalse)}


       <cond,σ> -> resCond:boolean
    -------------------------------- evalCond
          <this,σ> ~> resCond;


       <cond,σ> -> true 
    ---------------------- condTrue
     <this,σ> ~> <then,σ>;


       <cond,σ> -> false
    ---------------------- condFalse
     <this,σ> ~> <else,σ>;

} 

open non atomic rule Assignment {
          <right,σ> -> resRight: number         //here we cannot know the type. inference must be improved to avoid void type
    ------------------------------------------- evaluate
      <this,σ> ~> left.currentValue = resRight;
}
