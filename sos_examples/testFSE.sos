testSimpleL

import "./testSoSLang/src/language-server/simple-l.langium"



open Model { 

                            when starts
    ------------------------------------------------------------ statementsInOrder1
      <this,σ> ~> statements->sequential.foreach(s => <s,σ>)



        when statements.last().terminates
    -------------------------------------------                finishModel
              <this,σ> ~> terminates

}

open Bloc {

                          when starts
    -----------------------------------------------------      startsBloc
            <this,σ> ~> statements->sequential.foreach(s => <s,σ>)

  
              when statements.last().terminates            
        -------------------------------------------            finishBloc
                  <this,σ> ~> terminates
}

open ParallelBloc {

                          when starts
    -------------------------------------------------------------------- startsParallelBloc
      <this,σ> ~> statements->concurrent.foreach(s => emits s.starts)



      when lastOf(statements.terminates)
    -----------------------------------------                  finishParallelBloc
            <this,σ> ~> terminates

}

open Variable {

    var currentValue: integer;


                when starts
    ---------------------------------------------              initializeVar
     <this,σ> ~> currentValue := initialValue;
                 terminates 

}

open VarRef {
                  when starts
    ---------------------------------------------              accessVarRef 
      <this,σ> ~> emits terminates[theVar.currentValue]
  
} 

open If {

            when starts
    ------------------------------                             condStart
      <this,σ> ~> <cond,σ>


          when <cond,σ> -> true 
    -----------------------------------                        condTrueStart
          <this,σ> ~> <then,σ>


      when <cond,σ> -> false 
    -------------------------------                            condFalseStart
      <this,σ> ~> <else,σ>
      

        when (<else,σ>  v <then,σ> )
    -----------------------------------                        condStop
          <this,σ> ~> terminates

} 

open Assignment {
          when starts
    --------------------------                                  executeAssignment
      <this,σ> ~> <expr,σ>

          when <expr,σ> -> resRight:integer                       
    ----------------------------------------------------------- executeAssignment2
      <this,σ> ~> variable.currentValue := resRight; 
                  //variable.allReaders()->concurrent.foreach(r => r.updates)
                  terminates
}

// open Conjunction { //lazy version
//           when starts                   
//     -------------------------                                   evaluateConjunction
//       <this,σ> ~> <lhs,σ>

          
//       when <lhs,σ> -> true
//     -------------------------                                   evaluateConjunction2
//       <this,σ> ~> <rhs,σ>


//           when <lhs,σ> -> false
//     ----------------------------------                          evaluateConjunction3
//       <this,σ> ~> terminates//(false)

         
//           when <rhs,σ> -> res
//     -------------------------------                             evaluateConjunction4
//       <this,σ> ~> terminates//(res)

// }


open Conjunction { //parallel version
          when starts                   
    -------------------------                                   evaluateConjunction
      <this,σ> ~> <lhs,σ>
                  <rhs,σ>   
 
              when <lhs,σ> -> false
    -------------------------------------------------           evaluateConjunction2
          <this,σ> ~> terminates[false]

              when <rhs,σ> -> false
    -------------------------------------------------           evaluateConjunction3
          <this,σ> ~> terminates[false]

      when (<lhs,σ> -> true ^ <rhs,σ> -> true)
    -------------------------------------------------           evaluateConjunction4
          <this,σ> ~> terminates[true]
}

open Plus {
                  when starts
    -------------------------------------------                 startPlus
        <this,σ> ~> <right,σ>
                    <left,σ>
   
      when (<right,σ> -> n2:integer ^ <left,σ> -> n1:integer)
    ----------------------------------------------------------  finishPlus
        <this,σ> ~> terminates[(n1 + n2)]
}

open BooleanConst{

    var constantValue:boolean = value;

                    when starts
    -------------------------------------------                 evalBooleanConst
          <this,σ> ~> terminates[constantValue]
}